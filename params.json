{"name":"Creating a content recommendation engine using R, OpenCPU and GTM","tagline":"Proof of concept for connecting Google Tag Manager to R","body":"# Connecting R and Google Tag Manager with OpenCPU\r\n\r\nEnriching the dataLAyer of Google Tag Manager with data from R functions opens up many possibilities.  This is possible with [OpenCPU](https://www.opencpu.org), which turns R packages into a robust API.\r\n\r\nAn example and proof of concept is shown below, taking the example of a content recommendation engine making predictions based on what a user has viewed in their session.\r\n\r\n## Creating a content recommendation engine with R, OpenCPU and GTM\r\n\r\nThis presentation was given at MeasureCamp on the 5th March, 2016.  It will be available on the [IIH Nordic Blog](http://www.iihnordic.dk/blog)\r\n\r\n## Example website\r\n\r\nA live example with a GTM container calling OpenCPU for content predictions, as shown in the presentation is available in this [Github project, here](/predictClickOpenCPU/example/107.html)\r\n\r\n## R package called from OpenCPU\r\n\r\nThis Github repository is also the Github R library called by OpenCPU.  See the R code for the package and the [model data here.](https://github.com/MarkEdmondson1234/predictClickOpenCPU)\r\n\r\n## Using OpenCPU\r\n\r\n### Creating a webhook\r\n\r\nMake a Github webhook to OpenCPU, and then every push to Github will be mirrored onto the OpenCPU server.\r\n\r\n![github webhook](github_webhook.png)\r\n\r\n### Testing the model API works\r\n\r\nYou can test the model works in the API by using the test public server. \r\n\r\nFor production use though, you will want your own server, either using OpenCPU or the paid for alternatives such as [yhat](http://www.yhat.com) or [Domino Data Lab](https://www.dominodatalab.com)\r\n\r\nThis Github repository is available on OpenCPU at this URL:\r\n[https://MarkEdmondson1234.ocpu.io/predictClickOpenCPU/](https://MarkEdmondson1234.ocpu.io/predictClickOpenCPU/)\r\n\r\nSee details on how to use OpenCPU here: https://www.opencpu.org/api.html#api-ci\r\n\r\n### Test the R API package\r\n\r\nTest at: https://public.opencpu.org/ocpu/test/\r\n\r\nCreate a POST hit to this URL:\r\n\r\n`https://MarkEdmondson1234.ocpu.io/predictClickOpenCPU/R/predictMarkov/json`\r\n\r\n...with the parameters:\r\n\r\n`pageview_names`\r\n\r\n`[\"/example/96\",\"/example/213\",\"/example/107\"]`\r\n\r\nIf successful you should see a 200 response code with the following JSON:\r\n\r\n```\r\n{\r\n  \"page\": [\"da/search/tellus/planning-map\"],\r\n  \"probability\": [0.9664]\r\n}\r\n```\r\n\r\n![good test opencpu](openCPUdemo.png)\r\n\r\n\r\n## R code to generate the model\r\n\r\nThe R code to create the model is shown below:\r\n\r\n### Fetching Google Analytics data\r\n\r\n```r\r\n## from https://github.com/MarkEdmondson1234/googleAnalyticsR_public\r\nlibrary(googleAnalyticsR) \r\nga_auth()\r\n\r\ngaId <- xxxx # GA ViewId\r\n\r\n## dimension3 contains userId in format:\r\n## sl=1&u={cid}&t={timestamp}\r\nraw <- google_analytics(gaId,\r\n                        start = \"2016-02-01\",\r\n                        end = \"2016-02-01\",\r\n                        metrics = c(\"pageviews\"),\r\n                        dimensions = c(\"dimension3\", \"pagePath\"),\r\n                        # samplingLevel = \"WALK\",\r\n                        filters = \"ga:dimension3!~_scUid\",\r\n                        max_results = 20000)\r\n\r\n```\r\n\r\n\r\n### Transforming the data into a form suitable for the the model\r\n\r\n```r\r\nsplit_regex <- \"u=(.+)&t=(.+)\"\r\n\r\nprocessed <- raw %>% tidyr::extract(dimension3, \r\n                             c(\"cid\",\"timestamp\"),\r\n                             split_regex)\r\n\r\n## javascript to R timestamp\r\nprocessed$timestamp <- as.POSIXct(as.numeric(processed$timestamp) / 1000, \r\n                             origin = \"1970-01-01\")\r\n                             \r\n## find users with session length > 1\r\nnonbounce <- processed %>% group_by(cid) %>% \r\n  summarise(session_length = n()) %>% filter(session_length > 1) %>% ungroup()\r\n\r\nprocessed <- nonbounce %>% left_join(processed)\r\n\r\nprocessed <- processed %>% arrange(cid, timestamp)\r\n\r\n## for each cid, make a string of pagePath in timestamp order\r\nsequence <- processed %>% group_by(cid) %>% \r\n  summarise(sequence = paste(aggregation, collapse = \",\"))\r\n\r\nsequence <- paste(sequence$cid, sequence$sequence, sep=\",\")\r\n\r\n```\r\n\r\n### Creating the model\r\n\r\n```r\r\nlibrary(clickstream)\r\n\r\n# fitting a simple Markov chain and predicting the next click\r\nclickstreams <- sequence\r\ncsf <- tempfile()\r\nwriteLines(clickstreams, csf)\r\ncls <- readClickstreams(csf, header = TRUE)\r\n\r\n## Make the model:\r\n\r\n## 1612 users - 285 seconds\r\nmodel <- fitMarkovChain(cls, verbose=TRUE)\r\n\r\n### Using the model:\r\n\r\n## get the likely pages a user starts from\r\nlikely_start <- as.data.frame(model@start)\r\nlikely_start <- likely_start[order(likely_start$Freq, decreasing = TRUE),]\r\n\r\n## List of pages in the model\r\nstates(model)\r\n\r\n## Prediction:\r\nstartPattern <- new(\"Pattern\", sequence = c(\"blog\",\"sydjylland\"))\r\npredict(model, startPattern)\r\n\r\n## pages that absorb (e.g. are last in session)\r\nlast_pages <- absorbingStates(model)\r\n\r\n## model is saved so it can be uploaded to the R package for the predictions:\r\nsave(model, file=\"./data/model.RData\")\r\n\r\n```\r\n\r\n### Plotting the model\r\n\r\nIf you want to see the model, the below helps plot it:\r\n\r\n```r\r\nlibrary(igraph)\r\nexample_graph <- igraph::graph.adjacency(t(as.matrix(model@transitions[[1]])), \r\n                                 weighted = T)\r\n                                 likely_start <- as.data.frame(example_mc@start)\r\nlikely_start <- likely_start[order(likely_start$Freq, decreasing = TRUE),]\r\n\r\nlikely_plot <- likely_start[order(likely_start$Freq),]\r\nlikely_plot <- likely_plot[likely_plot$Freq > 0.02,]\r\n\r\n## make a sub graph as plotting them all is a big mess\r\nsub_graph <- graph.neighborhood(graph, \r\n                                order = 1, \r\n                                nodes = V(graph)[\"/example/96\" %in% as.character(likely_plot$Var1)]\r\n)[[1]]\r\n\r\n\r\n## the actual plot\r\nedgeLabels <-  paste0(round(igraph::E(sub_graph)$weight, 2)*100,\"%\")\r\nplot(sub_graph, edge.label = edgeLabels, \r\n     vertex.size = 15, \r\n     vertex.color=\"orange\",\r\n     # vertex.label = NA,\r\n     vertex.label.dist = 1,\r\n     vertex.label.cex=1.5,\r\n     vertex.label.color = \"orange\",\r\n     edge.label=1,\r\n     edge.label.cex=1.5,\r\n     edge.width =1.5,\r\n     edge.lty = 2,\r\n     edge.color = \"brown\",\r\n     edge.curved = TRUE,\r\n     edge.arrow.size = 1,\r\n     frame=TRUE,\r\n     asp = 0.8,\r\n     margin = 0.2,\r\n     main = \"Example Markov Chain for Website\")\r\n\r\n```\r\n\r\n## GTM code for calling OpenCPU\r\n\r\nThe custom HTML tag code is shown below:\r\n\r\n\r\n### Creating a cookie to record URL pages in the session\r\n\r\n```js\r\n//Tag : Write SessionUrls to Cookie\r\n<script>\r\n  \r\n  str = {{Page Path}};\r\n  \r\n  // parsing URL to fit model\r\n  index  = str.indexOf('.html');\r\n  newUrl = str.substring(str.lastIndexOf(\"/predictClickOpenCPU/\"),str.lastIndexOf(\".\"), index);\r\n  \r\n  // if existing cookie append pageURL, else record this one\r\n  if({{sessionUrls}}){\r\n    \r\n    sessionUrls = {{sessionUrls}} + \",\" + newUrl;\r\n\r\n  } else {\r\n    \r\n    sessionUrls = newUrl;\r\n  }\r\n\r\n  //write session cookie\r\n  document.cookie = 'sessionUrls=' + sessionUrls;\r\n  \r\n</script>\r\n\r\n```\r\n\r\n### Calling the OpenCPU server and putting result in dataLayer\r\n\r\n```js\r\n//Tag Read from OpenCPU\r\n<script src=\"//code.jquery.com/jquery-1.10.2.min.js\"></script> \r\n<script src=\"//www.opencpu.org/js/archive/opencpu-0.4.js\"></script>\r\n<script>\r\n//set CORS to call \"predictClickOpenCPU\" package on public server\r\nocpu.seturl(\"//MarkEdmondson1234.ocpu.io/predictClickOpenCPU/R\")\r\n\r\n//split character into array\r\nvar mydata = {{sessionUrls}}.split(\",\");\r\n  \r\nconsole.log(mydata);\r\n\r\n//call R function: predictClickOpenCPU::predictMarkov(pageview_names=mydata)\r\nvar req = ocpu.rpc(\"predictMarkov\", {\r\n    pageview_names : mydata\r\n  }, function(output){\r\n    dataLayer.push({\r\n              'event' : 'openCPUcall',\r\n              'prediction': output.page[0],\r\n              'probability': output.probability[0]\r\n            });\r\n    console.log(\"R returned: \" + output); \r\n});\r\n\r\n//optional\r\nreq.fail(function(){\r\n    console.log(\"R returned an error: \" + req.responseText); \r\n  });\r\n\r\n</script>\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}